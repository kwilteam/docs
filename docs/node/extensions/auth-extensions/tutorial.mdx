---
sidebar_position: 3
sidebar_label: "Tutorial"
id: auth-ext-tutorial
title: Authentication Extensions Tutorial
description: Full tutorial on how to create and use authentication extensions
slug: /extensions/authentication/tutorial
---

This tutorial will guide you through the process of creating and using an authentication extension that allows users to authenticate with ED25519 signatures. This tutorial will build on the concepts introduced in the [Authentication Extensions Overview](/docs/extensions/authentication/overview) documentations.

## Prerequisites

Make sure you follow the [kwil-db clone](/docs/extensions/quickstart#prerequisites) instructions and have all the necessary tools installed.

Additionally, you will need:

- [Node.js](https://nodejs.org/en/download/) - v18 or higher

## Step 1: Create the extension

Create a new directory in the `kwil-db/extensions` directory called `ed25519_demo`, and add a new file called `ed25519_example.go`.

### Verify ED25519 signatures

The first step is to implement the `Verify` method that will verify the ED25519 signature.

```go title="ed25519_example.go"
package ed25519_demo

import (
    "crypto/ed25519"
    "fmt"
	  "encoding/hex"

    "github.com/kwilteam/kwil-db/extensions/auth"
)

const (
    // Public Key Size
    PublicKeySize = ed25519.PublicKeySize
    // Signature Size
    SignatureSize = ed25519.SignatureSize
)

type Ed25519Authenticator struct{}

func (Ed25519Authenticator) Verify(sender, msg, signature []byte) error {
    if len(sender) != PublicKeySize {
        return fmt.Errorf("invalid signature size. expected %d, got %d", sender, len(sender))
    }

    if len(signature) != SignatureSize {
        return fmt.Errorf("invalid signature size. expected %d, got %d", SignatureSize, len(signature))
    }

    if !ed25519.Verify(sender, msg, signature) {
        return fmt.Errorf("signature verification failed")
    }

    return nil
}
```

### Identifier

The next step is to implement the `Identifier` method that will return a unique identifier for the signer. For ED25519, we will use the public key as the identifier.

```go title="ed25519_example.go"
package ed25519_demo

import (
    "crypto/ed25519"
	"fmt"
)

const (
    // Name is the name of the extension
    Name = "ed25519_example"
    // Singature size
    SignatureSize = ed25519.SignatureSize
	// Public key size
	PublicKeySize = ed25519.PublicKeySize
)

type Ed25519Authenticator struct{}

func (Ed25519Authenticator) Verify(sender, msg, signature []byte) error {
    if len(sender) != PublicKeySize {
        return fmt.Errorf("invalid signature size. expected %d, got %d", sender, len(sender))
    }

    if len(signature) != SignatureSize {
        return fmt.Errorf("invalid signature size. expected %d, got %d", SignatureSize, len(signature))
    }

    if !ed25519.Verify(sender, msg, signature) {
        return fmt.Errorf("signature verification failed")
    }

    return nil
}
```

### Register the extension

The final step is to register the extension with the `auth` package. This is called in the `init` function of the ed25519_demo package.

```go title="ed25519_example.go"
package ed25519_demo

import (
    "crypto/ed25519"
    "fmt"
	  "encoding/hex"

    "github.com/kwilteam/kwil-db/extensions/auth"
)

const (
    // Name is the name of the extension
    Name = "ed25519_example"
)

type Ed25519Authenticator struct{}

func init() {
    err := auth.RegisterAuthenticator(Name, Ed25519Authenticator{})
    if err != nil {
        panic(err)
    }
}
```

### Full Example

Below is the full example of the `ed25519_example.go` to create the extension. You can copy and paste this example for the build process in the next step.

<details>
<summary>ed25519_example.go</summary>

```go title="ed25519_example.go"
package ed25519_demo

import (
    "crypto/ed25519"
    "fmt"
	  "encoding/hex"

    "github.com/kwilteam/kwil-db/extensions/auth"
)

const (
    // Name is the name of the extension
    Name = "ed25519_example"
    // Public Key Size
    PublicKeySize = ed25519.PublicKeySize
    // Signature Size
    SignatureSize = ed25519.SignatureSize
)

func init() {
    err := auth.RegisterAuthenticator(Name, Ed25519Authenticator{})
    if err != nil {
        panic(err)
    }
}

type Ed25519Authenticator struct{}

func (Ed25519Authenticator) Verify(sender, msg, signature []byte) error {
    if len(sender) != PublicKeySize {
        return fmt.Errorf("invalid signature size. expected %d, got %d", sender, len(sender))
    }

    if len(signature) != SignatureSize {
        return fmt.Errorf("invalid signature size. expected %d, got %d", SignatureSize, len(signature))
    }

    if !ed25519.Verify(sender, msg, signature) {
        return fmt.Errorf("signature verification failed")
    }

    return nil
}

func (Ed25519Authenticator) Identifier(publicKey []byte) (string, error) {
    if(len(publicKey) != ed25519.PublicKeySize) {
        return "", fmt.Errorf("invalid public key size. expected %d, got %d", ed25519.PublicKeySize, len(publicKey))
    }

    return hex.EncodeToString(publicKey), nil
}
```

</details>

## Step 2: Compile and Start Node

Follow the instructions in the extension [build quickstart](/docs/extensions/quickstart#compiling-the-extension) to compile the extension and start the node.

## Step 3: Use the extension in client app

### Repo setup

Once the node is compiled and running, we can build a simple client-side application to use the authentication extension.

Create a new repository:

```bash
mkdir ed25519-demo
cd ed25519-demo
npm init -y
npm i @kwilteam/kwil-js tweetnacl
npm i -D typescript ts-node
tsc --init --resolveJsonModule
```

### Get Chain ID

Using the `kwil-cli` that was compiled into the `.build` directory in step 3, get the chain ID for the network you are running. Run the following command from the **root of the `kwil-db` repository**.

```bash
.build/kwil-cli utils chain-info --kwil-provider http://localhost:8080
# highlight-next-line
Chain ID: kwil-chain-xxxxx
```

### Create NodeKwil and KwilSigner instances

In the `ed25519-demo` repository, create a new file called `kwil.ts` and add the following. Use the chain ID from the previous step.

```typescript title="kwil.ts"
import { NodeKwil, KwilSigner } from "@kwilteam/kwil-js";
import nacl from "tweetnacl";

export const kwil = new NodeKwil({
    kwilProvider: "http://localhost:8080",
    chainId: "kwil-chain-n1bbEwwN",
})

// create keypair
const keys = nacl.sign.keyPair(); // Generate a key pair, or load an existing one

// create a signer callback function
const signatureCb = async (msg: Uint8Array) => {
    return nacl.sign.detached(msg, keys.secretKey);
}

// create a KwilSigner instance, passing the signature callback, public key, and extension name
export const ed25519Signer = new KwilSigner(signatureCb, keys.publicKey, 'ed25519_example');
```

### Create Kuneiform Schema

In the `ed25519-demo` repository, copy the following schema into a new file called `schema.json`.

<details>
<summary>schema.json</summary>

```json
{
  "owner": "",
  "name": "hello_ed",
  "tables": [
    {
      "name": "message",
      "columns": [
        {
          "name": "id",
          "type": "int",
          "attributes": [
            {
              "type": "primary_key"
            },
            {
              "type": "not_null"
            }
          ]
        },
        {
          "name": "message",
          "type": "text",
          "attributes": [
            {
              "type": "not_null"
            }
          ]
        },
        {
          "name": "caller",
          "type": "text",
          "attributes": [
            {
              "type": "not_null"
            }
          ]
        }
      ]
    }
  ],
  "actions": [
    {
      "name": "insert_record",
      "inputs": [
        "$id",
        "$message"
      ],
      "public": true,
      "mutability": "update",
      "auxiliaries": null,
      "statements": [
        "INSERT INTO message (id, message, caller)\n    VALUES ($id, $message, @caller);"
      ]
    }
  ]
}
```

</details>

In the schema, we have defined a table `message` with three columns: `id`, `message`, and `caller`. We have also defined an action `insert_record` that will insert a new record into the `message` table. The @caller variable will use the [`Identifier`](/docs/extensions/authentication/overview#identifier) that was configured in our extension.

:::note
The reason why the schema is JSON and not Kuneiform is because the Kuneiform parser is not yet available in the `kwil-js` library.
:::

### Deploy the schema

Create a new file called `index.ts` and add the following to sign and send a deploy transaction with the custom signer.

```typescript title="index.ts"
import { kwil, ed25519Signer } from "./kwil";
import schema from "./schema.json";

async function deploy() {
    const res = await kwil.deploy({
        schema
    }, ed25519Signer, true);

    console.log(res);
}

deploy();
```

Run the deploy script:

```bash
ts-node index.ts
```

Once the database successfully deploys, you will receive a success message. You can now use the `ed25519Signer` to sign and send transactions to the Kwil network.

## Conclusion

In this tutorial, you learned how to create and use an authentication extension that allows users to authenticate with ED25519 signatures. You also learned how to use the extension in a client-side application to sign and send transactions to the Kwil network.

### Next Steps

To learn more about other extension types, check out the following documentation: 

- [Action Extensions](/docs/extensions/actions/overview)
- [Oracle Extensions](/docs/extensions/oracle/overview)
- [Resolution Extensions](/docs/extensions/resolution/overview)