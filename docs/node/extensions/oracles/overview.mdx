---
sidebar_position: 1
sidebar_label: "Overview"
id: oracles-ext-overview
title: Building Oracles
description: Overview of the Oracles Extension
slug: /extensions/oracles/overview
---

Kwil nodes can be programmed to act as network oracles, automatically triggering network changes based on external events.
This can be used to enforce payments from tokens originating on other networks, dictate validator weight based on an external staking system,
or verifiably synchronize data from other networks within the Kwil network.

Oracle extensions use the `extensions/oracles` package in kwil-db.

## Oracle Extension Overview

To build an oracle extension, you must implement the `OracleFunc` function signature, and register the oracle using the `RegisterOracle` function.

### RegisterOracle Function

Oracles are registered using the `RegisterOracle` in the package's init function. The first argument is the unique name for the oracle, and the second argument is the [oracle function](#oracle-function-signature).

```go
package custom_oracle

import (
    "github.com/kwilteam/kwil-db/extensions/oracles"
)

func init() {
    err := oracles.RegisterOracle("my-oracle", myOracle)
    if err != nil {
        panic(err)
    }
}
```

#### API Reference

<details>
<summary>RegisterOracle API Reference</summary>

```go
func RegisterOracle(name string, oracle OracleFunc) error {}
```

- `name` (string): The unique name for the oracle.
- `oracle` (OracleFunc): The oracle function to be called when the node is promoted to a validator.

</details>

## Oracle Function

Oracles can be implemented using the `OracleFunc` function signature. Each registered oracle function is called exactly once during
startup, and is expected to block indefinitely. It will not be called if the local node is not a validator, or if it is still syncing with the network. If a non-validator
node is promoted to a validator, the oracle function will be called immediately.

The oracle function should clean up any resources and return when the context is canceled. The context is cancelled when the node is shutting down,
or when the node is demoted from a validator.

```go
package custom_oracle

import (
    "context"

    "github.com/kwilteam/kwil-db/extensions/oracles"
    "github.com/kwilteam/kwil-db/common"
)

func myOracle(ctx context.Context, service *common.Service, eventstore oracles.EventStore) {
    for {
        select {
        case <-ctx.Done():
            return
        // other logic
        }
    }
}
```

_An example oracle capable of crediting native Kwil accounts from EVM events
can be found [here](<https://github.com/kwilteam/kwil-db/tree/main/extensions/oracles/eth_deposits>)._

#### API Reference

<details>
<summary>OracleFunc API Reference</summary>

```go
type OracleFunc func(ctx context.Context, service *common.Service, eventstore EventStore)
```

- `ctx` (context.Context): The Go context type.
- `service` (*common.Service): The service struct, which provides access to general application information to extensions (e.g. logger).
- `eventstore` (EventStore): The [event store interface](#eventstore), which allows oracles to persist events and track arbitrary metadata about its external source.

</details>

## EventStore

Data can be written to the network using the `oracles.EventStore` interface. Data is broadcasted using the `Broadcast` method.
The `Set`, `Get`, and `Delete` methods can be used to store and retrieve metadata about the data source. The `Set`, `Get`, and `Delete` methods
are purely for the convenience of the oracle implementer, and in no way affect the network state.

```go
package oracles

import "context"

// EventStore is an interface that allows oracles to persist events, and track
// arbitrary metadata about its external source. It should be used to signal
// to the local Kwil node that the validator has seen an event, and that the
// event should be broadcast to the network.
// Events should be broadcast to the network using the Broadcast method.
// The KV store data is never forwarded to the network, and is simply
// for the convenience of the oracle implementer to persist metadata about
// the data source.
type EventStore interface {
	// Broadcast broadcasts an event seen by the local node to the network.
	// The eventType is a string that identifies the network should interpret the data.
	// The eventType should directly correspond to a "resolution" type, implemented in
	// the resolutions package. The data argument will be passed to the resolution's
	// ResolveFunc if enough nodes vote on the resolution.
	Broadcast(ctx context.Context, eventType string, data []byte) error

	// Set sets a key-value pair in the KV store.
	// The data is scoped to the local node, and is not broadcast to the network.
	Set(ctx context.Context, key []byte, value []byte) error
	// Get gets a value from the local node's KV store.
	Get(ctx context.Context, key []byte) ([]byte, error)
	// Delete deletes a value from the local node's KV store.
	// The data is scoped to the local node, and is not broadcast to the network.
	Delete(ctx context.Context, key []byte) error
}

```

Data broadcasted must match a registered resolution type, found in `extensions/resolutions`. For more information on available resolutions, as well
as how to register custom resolutions, see the [Resolution Extensions section](/docs/node/extensions/resolutions/overview).

```go
package custom_oracle

import (
    "context"

    "github.com/kwilteam/kwil-db/extensions/oracles"
    "github.com/kwilteam/kwil-db/common"
)

func myOracle(ctx context.Context, service *common.Service, eventstore oracles.EventStore) {
    for {
        select {
        case <-ctx.Done():
            return
        case <-time.After(5 * time.Second):
            err := eventstore.Broadcast(ctx, "event-type", []byte("hello world"))
            if err != nil {
                log.Println(err)
            }
        }
    }
}
```

## Configuration

Local configurations set by each individual node operator can be used to control the behavior of the oracle. This can be used to set RPC endpoints,
API keys, or simply to enable or disable the oracle. Local configurations can be set in each node operator's `config.toml`.
More information on how to set local node configurations can be found [here](</docs/daemon/config/settings>).

Given the following `config.toml`:

```toml title="config.toml"
# ...
[app.extensions.my_oracle]
rpc_endpoint = "https://my-rpc-endpoint.com"
# ...
```

Configurations can be accessed in the `common.Service` struct:

```go
package custom_oracle

import (
    "context"

    "github.com/kwilteam/kwil-db/extensions/oracles"
    "github.com/kwilteam/kwil-db/common"
)

func myOracle(ctx context.Context, service *common.Service, eventstore oracles.EventStore) {
    myOracleConfig, ok := service.ExtensionConfigs["my_oracle"]
    if !ok {
        // if no configuration is set, don't run the oracle
        log.Println("my_oracle not configured")
        return
    }

    rpcEndpoint, ok := myOracleConfig["rpc_endpoint"]
    if !ok {
        // if no rpc_endpoint is set, don't run the oracle
        log.Println("rpc_endpoint not configured")
        return
    }

    // other logic
}
```