---
sidebar_position: 2
sidebar_label: "Tutorial"
id: oracles-ext-tutorial
title: Building Oracles
description: Overview of the Oracles Extension
slug: /extensions/oracles/tutorial
---

In this tutorial, we will build a simple oracle that listens to EVM events, and credits an account when a log is heard.
The oracle will be configured to listen to a specific contract address, and will listen to the EVM event signature `Credit(address,uint256)`

This tutorial relies on the `credit_account` resolution extension, which is supported in Kwil by default. A tutorial on how to recreate this resolution
extension from scratch can be found [resolution extension documentation](/docs/node/extensions/resolutions/tutorial).

**This tutorial is for example purposes only, and should not be used in production.** Production implementations should account for transient network failures,
subscription disconnections, Ethereum reorgs, and other edge cases. For a production-ready implementation of this oracle, please refer to the [Kwil EVM Oracle](<https://github.com/kwilteam/kwil-db/tree/main/extensions/oracles/eth_deposits>) that is
included in all Kwil nodes by default.

## Prerequisites

Make sure you follow the [kwil-db clone](/docs/extensions/quickstart#prerequisites) instructions and have all the necessary tools installed.

## Step 1. Querying Ethereum

To get started, we will first need a way to query the Ethereum blockchain for new events. We will use the popular `go-ethereum` library, which is the
core implementation of Ethereum.

Create a new directory in the `kwil-db/extensions` directory called `eth_credit`, and create a new file called `credit.go`.

```go title="credit.go"
package eth_credit

import (
	"context"
	"math/big"
	"strings"

	"github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/ethereum/go-ethereum/accounts/abi"
	ethcommon "github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/ethclient"
	"github.com/kwilteam/kwil-db/extensions/oracles"
	"github.com/kwilteam/kwil-db/extensions/resolutions/credit"
)

// contractABIStr is the ABI of the smart contract the oracle listens to.
// It follows the Ethereum ABI JSON format, and matches the `Credit(address,uint256)` event signature.
const contractABIStr = `[{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"_from","type":"address"},{"indexed":false,"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"Credit","type":"event"}]`

// creditEventSignature is the EVM event signature the oracle listens to.
var creditEventSignature ethcommon.Hash = crypto.Keccak256Hash([]byte("Credit(address,uint256)"))

// processBlock gets all credit events for a range of blocks and processes them.
// it will broadcast the credit events to the Kwil network.
func processBlock(ctx context.Context, eventstore oracles.EventStore, client *ethclient.Client, blockNumber int64, contract ethcommon.Address) error {
	// query the logs for the credit event
	logs, err := client.FilterLogs(ctx, ethereum.FilterQuery{
		ToBlock:   big.NewInt(blockNumber),
		FromBlock: big.NewInt(blockNumber),
		Addresses: []ethcommon.Address{contract},
		Topics:    [][]ethcommon.Hash{{creditEventSignature}},
	})
	if err != nil {
		return err
	}

	// get the abi, so that we can decode the logs+
	eventABI, err := abi.JSON(strings.NewReader(contractABIStr))
	if err != nil {
		return err
	}

	for _, log := range logs {
		data, err := eventABI.Unpack("Credit", log.Data)
		if err != nil {
			return err
		}

		// data[0] is the address of the account to credit
		// data[1] is the amount to credit the account

		account := data[0].(ethcommon.Address)
		amount := data[1].(*big.Int)

		// get the resolution from the credt resolution extension
		resolution := credit.AccountCreditResolution{
			Account: account.Bytes(),
			Amount:  amount,
            TxHash:  log.TxHash.Bytes(),
		}

		bts, err := resolution.MarshalBinary()
		if err != nil {
			return err
		}

		// broadcast the resolution to the network
		err = eventstore.Broadcast(ctx, credit.CreditAccountEventType, bts)
		if err != nil {
			return err
		}
	}

	return nil
}
```

:::tip
You may notice that the `credit` resolution extension is used in the oracle. The `credit` resolution extension allows nodes to credit accounts with a specified amount.

The `credit` resolution extension is a default resolution extension that is included in all Kwil nodes.

You can learn more about building resolution extensions in the [resolution extension documentation](/docs/extensions/resolutions/overview).
:::	

## Step 2. Listening to Ethereum

In order to listen to Ethereum, we will need to read in our local node's configuration, create a client, and listen for new blocks.
If the configuration is not set, or if the configuration is invalid, we will immediately shut down the oracle. We will also stop the oracle
if the context is cancelled.

```go title="credit.go"
package eth_credit

import (
	"context"

	ethcommon "github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/ethclient"
	"github.com/kwilteam/kwil-db/extensions/oracles"
)

// EthOracle is an oracle that listens to ethereum events and broadcasts corresponding
// account credits to the Kwil network.
func EthOracle(ctx context.Context, service *common.Service, eventstore oracles.EventStore) {
	// we will first get the configs that the local node has for the eth_oracle extension
	config, ok := service.ExtensionConfigs["eth_oracle"]
	if !ok {
		fmt.Println("eth_oracle: config not found")
		return
	}

	rpcProvider, ok := config["rpc_provider"]
	if !ok {
		fmt.Println("eth_oracle: rpc_provider not found in config")
		return
	}

	contractAddressStr, ok := config["contract_address"]
	if !ok {
		fmt.Println("eth_oracle: contract_address not found in config")
		return
	}
	contractAddress := ethcommon.HexToAddress(contractAddressStr)

	// we will now use go-ethereum to subscribe to new blocks
	client, err := ethclient.Dial(rpcProvider)
	if err != nil {
		fmt.Println("eth_oracle: failed to connect to ethereum client:", err)
		return
	}
	defer client.Close()

	headers := make(chan *types.Header)
	sub, err := client.SubscribeNewHead(ctx, headers)
	if err != nil {
		fmt.Println("eth_oracle: failed to subscribe to new block headers:", err)
		return
	}
	defer sub.Unsubscribe()

	// we will now listen for new blocks and process them
	// if the context is cancelled, we will stop listening
	for {
		select {
		case <-ctx.Done():
			return
		case err := <-sub.Err():
			fmt.Println("eth_oracle: subscription error:", err)
			return
		case header := <-headers:
			err := processBlock(ctx, eventstore, client, header.Number.Int64(), contractAddress)
			if err != nil {
				fmt.Println("eth_oracle: failed to process block:", err)
			}
		}
	}
}
```

## Step 3. Configuration

In order to run the oracle, each Kwil node will need to configure an Ethereum RPC provider and smart contract address to listen to.
This can be done in each node's local `config.toml` file:

```toml title="config.toml"
# ...
[app.extensions.eth_oracle]
rpc_provider = "https://mainnet.infura.io/v3/YOUR_INFURA_API_KEY"
contract_address = "0xYOUR_CONTRACT_ADDRESS"
# ...
```

:::tip
Node files are automatically generated when a node is started with the [--autogen flag](/docs/node/quickstart#single-node). You can also generate files with the [`kwil-admin` tool](/docs/admin/setup#quick-setup-of-a-single-kwil-node).
:::

The values set here will be read in by the oracle, and used to connect to the Ethereum network and listen to the specified contract address.

## Step 4. Register the Oracle

The last step is to register the oracle with the Kwil node. This is done by calling the `RegisterOracle` function in the package's `init` function.

```go title="credit.go"
package eth_credit

import (
	"github.com/kwilteam/kwil-db/extensions/oracles"
)

func init() {
	err := oracles.RegisterOracle("eth_oracle", EthOracle)
	if err != nil {
		panic(err)
	}
}
```

## Full Example

The full example of the oracle extension implemented in this tutorial is shown below:

<details>
    <summary>credit.go</summary>

```go title="credit.go"
package eth_credit

import (
	"context"
	"fmt"
	"math/big"
	"strings"

	"github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	ethcommon "github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/ethereum/go-ethereum/ethclient"
	"github.com/kwilteam/kwil-db/common"
	"github.com/kwilteam/kwil-db/extensions/oracles"
	"github.com/kwilteam/kwil-db/extensions/resolutions/credit"
)

// EthOracle is an oracle that listens to ethereum events and broadcasts corresponding
// account credits to the Kwil network.
func EthOracle(ctx context.Context, service *common.Service, eventstore oracles.EventStore) {
	// we will first get the configs that the local node has for the eth_oracle extension
	config, ok := service.ExtensionConfigs["eth_oracle"]
	if !ok {
		fmt.Println("eth_oracle: config not found")
		return
	}

	rpcProvider, ok := config["rpc_provider"]
	if !ok {
		fmt.Println("eth_oracle: rpc_provider not found in config")
		return
	}

	contractAddressStr, ok := config["contract_address"]
	if !ok {
		fmt.Println("eth_oracle: contract_address not found in config")
		return
	}
	contractAddress := ethcommon.HexToAddress(contractAddressStr)

	// we will now use go-ethereum to subscribe to new blocks
	client, err := ethclient.Dial(rpcProvider)
	if err != nil {
		fmt.Println("eth_oracle: failed to connect to ethereum client:", err)
		return
	}
	defer client.Close()

	headers := make(chan *types.Header)
	sub, err := client.SubscribeNewHead(ctx, headers)
	if err != nil {
		fmt.Println("eth_oracle: failed to subscribe to new block headers:", err)
		return
	}
	defer sub.Unsubscribe()

	// we will now listen for new blocks and process them
	// if the context is cancelled, we will stop listening
	for {
		select {
		case <-ctx.Done():
			return
		case err := <-sub.Err():
			fmt.Println("eth_oracle: subscription error:", err)
			return
		case header := <-headers:
			err := processBlock(ctx, eventstore, client, header.Number.Int64(), contractAddress)
			if err != nil {
				fmt.Println("eth_oracle: failed to process block:", err)
			}
		}
	}
}

// contractABIStr is the ABI of the smart contract the oracle listens to.
// It follows the Ethereum ABI JSON format, and matches the `Credit(address,uint256)` event signature.
const contractABIStr = `[{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"_from","type":"address"},{"indexed":false,"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"Credit","type":"event"}]`

// creditEventSignature is the EVM event signature the oracle listens to.
var creditEventSignature ethcommon.Hash = crypto.Keccak256Hash([]byte("Credit(address,uint256)"))

// processBlock gets all credit events for a range of blocks and processes them.
// it will broadcast the credit events to the network.
func processBlock(ctx context.Context, eventstore oracles.EventStore, client *ethclient.Client, blockNumber int64, contract ethcommon.Address) error {
	// query the logs for the credit event
	logs, err := client.FilterLogs(ctx, ethereum.FilterQuery{
		ToBlock:   big.NewInt(blockNumber),
		FromBlock: big.NewInt(blockNumber),
		Addresses: []ethcommon.Address{contract},
		Topics:    [][]ethcommon.Hash{{creditEventSignature}},
	})
	if err != nil {
		return err
	}

	// get the abi, so that we can decode the logs+
	eventABI, err := abi.JSON(strings.NewReader(contractABIStr))
	if err != nil {
		return err
	}

	for _, log := range logs {
		data, err := eventABI.Unpack("Credit", log.Data)
		if err != nil {
			return err
		}

		// data[0] is the address of the account to credit
		// data[1] is the amount to credit the account

		account := data[0].(ethcommon.Address)
		amount := data[1].(*big.Int)

		resolution := credit.AccountCreditResolution{
			Account: account.Bytes(),
			Amount:  amount,
            TxHash:  log.TxHash.Bytes(),
		}

		bts, err := resolution.MarshalBinary()
		if err != nil {
			return err
		}

		err = eventstore.Broadcast(ctx, credit.CreditAccountEventType, bts)
		if err != nil {
			return err
		}
	}

	return nil
}

func init() {
	err := oracles.RegisterOracle("eth_oracle", EthOracle)
	if err != nil {
		panic(err)
	}
}
```

</details>

To build and run the oracle extension example, follow the standard [extension build and run](/docs/extensions/quickstart) process.
