---
sidebar_position: 1
sidebar_label: "Overview"
id: resolutions-ext-overview
title: Building Network Resolutions
description: Overview of Resolutions
slug: /extensions/resolutions/overview
---

Resolutions are custom network rules that can be voted on by the validator set to enact a change on the network. They can be used to enact forms of network governance, as well as to perform automatic state changes on the network via the use of oracles.

You can think of resolution extensions as a way to add custom transactions types to your Kwil network. Just as deploying a database, executing and action, and transferring funds between users, resolution extensions allow you to define custom transactions that nodes can vote on and, if passed, execute.

Resolution extensions use the `extensions/resolutions` package in kwil-db.

## Resolution Extension Overview

To build a resolution extension, you must implement the `ResolutionConfig` struct, and register the extension using the `RegisterResolution` function.

### RegisterResolution Function

Resolutions are registered using the `RegisterResolution` in the package's init function. The first argument is the unique name of the resolution, and the second argument is the `ResolutionConfig` struct that defines the resolution.

```go
package custom_resolution

import (
	"github.com/kwilteam/kwil-db/extensions/resolutions"
)

func init() {
	err := resolutions.RegisterResolution("my-resolution", resolutionConfig)
	if err != nil {
		panic(err)
	}
}
```

#### API Reference

<details>
<summary>RegisterResolution API Reference</summary>

```go
func RegisterResolution(name string, resolution ResolutionConfig) error {}
```

- `name` is the unique name of the resolution. This is used to identify the resolution in the network.

- `resolution` is the `ResolutionConfig` struct that defines the resolution.

</details>

### ResolutionConfig Struct

Resolutions can be defined using the `ResolutionConfig` struct found in the `extensions/resolutions` module. Using this struct, implementers can define
how many votes are needed to pass a resolution type, how long a resolution should be valid for before expiring, whether there should be refunds on expiration,
and what function should be called when a resolution is confirmed.

:::tip
An example resolution that credits Kwil accounts with gas tokens can be found [here](<https://github.com/kwilteam/kwil-db/blob/main/extensions/resolutions/credit/credit.go>).
:::

```go
package custom_resolution

import (
	"context"
	"math/big"

	"github.com/kwilteam/kwil-db/common"
	"github.com/kwilteam/kwil-db/extensions/resolutions"
)

var resolutionConfig = resolutions.ResolutionConfig{
	RefundThreshold:       big.NewRat(1, 3), // >1/3rds of nodes must vote on a resolution for refund to occur
	ConfirmationThreshold: big.NewRat(2, 3), // >2/3rds of nodes must vote on a resolution for it to be confirmed
	ExpirationPeriod:	   600, // 600 blocks after submission, the resolution will expire (approx 1 hour)
	ResolveFunc:           func(ctx context.Context, app *common.App, resolution *resolutions.Resolution) error {
		// Your resolution logic here
		return nil
	},
}
```

:::warning
**The `ResolveFunc` must be deterministic.** All nodes will run the `ResolveFunc` when a resolution is confirmed, and different results will create a consensus failure.
:::

:::warning
**Resolution bodies in `resolution.Body` must be unique.** The `ID` of a resolution is deterministically generated from the body of the resolution, and two resolutions with the same body will have the same ID. The network will reject a resolution resolution with the same ID as an existing resolution.
:::

More info on the `ResolutionConfig` and `Resolution` structs can be found in the Type Definitions below.

#### Type Definitions

The full type definitions for the `ResolutionConfig` and `Resolution` structs can be found below.


<details>
<summary>ResolutionConfig Type Definition</summary>

```go
package resolutions

import (
	"context"
	"fmt"
	"math/big"

	"github.com/kwilteam/kwil-db/common"
	"github.com/kwilteam/kwil-db/core/types"
)

// ResolutionConfig is a configuration for a type of resolution.
// It can be used to define resolutions that a Kwil network can vote on,
// and define the resulting logic if the resolution receives the required number of votes.
type ResolutionConfig struct {
	// RefundThreshold is the required vote percentage threshold for all voters
	// on a resolution to be refunded the gas costs associated with voting.
	// This allows for resolutions that have not received enough votes to pass
	// to refund gas to the voters that have voted on the resolution.
	// For a 1/3rds threshold, >=1/3rds of the voters must vote for the resolution for refunds to occur.
	// If this threshold is not met, voters will not be refunded when the resolution expires.
	// The number must be a fraction between 0 and 1.
	// If this field is nil, it will default to only refunding voters when the resolution is confirmed.
	RefundThreshold *big.Rat
	// ConfirmationThreshold is the required vote percentage threshold for whether
	// a resolution is confirmed. In a 2/3rds threshold,
	// >=2/3rds of the voters must vote for the resolution for it to be confirmed.
	// Voters will also be refunded if this threshold is met,
	// regardless of the refund threshold.
	// The number must be a fraction between 0 and 1.
	// If this field is nil, it will default to 2/3.
	ConfirmationThreshold *big.Rat
	// ExpirationPeriod is the amount of blocks that the resolution will be valid for before it expires.
	// It is applied additively to the current block height when the resolution is proposed; if the
	// current block height is 10 and the expiration height is 5, the resolution will expire at block 15.
	// If this field is <1, it will default to 14400, which is approximately 1 day assuming 6 second blocks.
	ExpirationPeriod int64
	// ResolveFunc is a function that is called once a resolution has received a required number of votes,
	// as defined by the ConfirmationThreshold. It is given a readwrite database connection and the information
	// for the resolution that has been confirmed. All nodes will call this function as a part of block
	// execution. It is therefore expected that the function is deterministic, regardless of a node's
	// local configuration.
	ResolveFunc func(ctx context.Context, app *common.App, resolution *Resolution) error
}
```

- `RefundThreshold` is the required vote percentage threshold for all voters on a resolution to be refunded the gas costs associated with voting. If the percentage of validators voting for the resolution exceeds the threshold, the voters will be refunded.

- `ConfirmationThreshold` is the required vote percentage threshold for whether a resolution is confirmed. If the percentage of validators voting for the resolution exceeds the threshold, the resolution will be confirmed.

- `ExpirationPeriod` is the amount of blocks that the resolution will be valid for before it expires. For example, if the current block height is 10 and the expiration height is 5, the resolution will expire at block 15. By default, block times are 6 seconds, so an expiration period of 14400 is approximately 1 day.

- `ResolveFunc` is a function that is called once a resolution has received a required number of votes, as defined by the ConfirmationThreshold. It has access to the database and will be called on all nodes once a resolution is confirmed. **The `ResolveFunc` must be deterministic,** or you may get a consensus failure.

</details>

<details>
<summary>Resolution Type Definition</summary>

```go
package resolutions

import (
	"context"
	"fmt"
	"math/big"

	"github.com/kwilteam/kwil-db/common"
	"github.com/kwilteam/kwil-db/core/types"
)

// Resolution contains information for a resolution that can be voted on.
type Resolution struct {
	// ID is the unique identifier for the resolution.
	// It is a UUID that is deterministically generated from the body of the resolution.
	ID types.UUID
	// Body is the content of the resolution.
	// It can hold any arbitrary data that is relevant to the resolution.
	Body []byte
	// Type is the type of the resolution.
	// It is used to determine the logic for the resolution.
	Type string
	// ExpirationHeight is the block height at which the resolution is set to expire,
	// if it has not received the required number of votes.
	ExpirationHeight int64
	// ApprovedPower is the total power of the voters that have approved the resolution.
	ApprovedPower int64
	// Voters is a list of voters that have voted on the resolution.
	// This includes the proposer of the resolution.
	Voters []*types.Validator
	// Proposer is the voter that proposed the resolution body.
	// The power of the proposer can be found in the Voters list.
	Proposer []byte
	// DoubleProposerVote indicates whether or not the proposer voted twice on the resolution.
	// This tracks a special case in the Kwil voting process where a resolution can be voted
	// on before it has been officially proposed. If a validator votes on a resolution and\
	// later proposes the same resolution, this will be true. The proposer's power is not
	// counted twice in the resolution's ApprovedPower.
	// Most applications can ignore this field.
	DoubleProposerVote bool
}
```

- `ID` is the unique identifier for the resolution.

- `Body` is the content of the resolution.

- `Type` is the type of the resolution. For a resolution extension, this will be the unique name of the resolution.

- `ExpirationHeight` is the block height the resolution will expire at if not approved.

- `ApprovedPower` is the total power of the validators that have approved the resolution.

- `Voters` is a list of voters that have voted on the resolution. This includes the proposer of the resolution.

- `Proposer` is the voter that proposed the resolution body.

- `DoubleProposerVote` indicates whether or not the proposer voted twice on the resolution. Most applications can ignore this field.

</details>


## Resolution Voting

Currently, the only way to vote on a custom resolution is through the use of [oracle extensions](/docs/extensions/oracles/overview). In the future, we plan to allow resolutions to
be voted on directly using the CLI.

At the end of each block, the network will first check for all resolutions that have received enough votes to be confirmed. If a resolution has received
enough votes, the `ResolveFunc` will be called, and the resolution will be removed from the network. The network will then check for all resolutions that have
expired, and refund the gas costs to the voters if the refund threshold has been met.