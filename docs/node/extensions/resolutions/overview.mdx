---
sidebar_position: 1
sidebar_label: "Overview"
id: resolutions-ext-overview
title: Building Network Resolutions
description: Overview of Resolutions
slug: /extensions/resolutions/overview
---

Resolutions are custom network rules that can be voted on by the validator set to enact a change on the network. They can be used to enact forms of network governance,
as well as to perform automatic state changes on the network via the use of oracles.

## Resolution Definition

Resolutions can be defined using the `ResolutionConfig` struct found in the `extensions/resolutions` module. Using this struct, implementers can define
how many votes are needed to pass a resolution type, how long a resolution should be valid for before expiring, whether there should be refunds on expiration,
and what function should be called when a resolution is confirmed.

```go
package resolutions

import (
	"context"
	"fmt"
	"math/big"

	"github.com/kwilteam/kwil-db/common"
	"github.com/kwilteam/kwil-db/core/types"
)

// ResolutionConfig is a configuration for a type of resolution.
// It can be used to define resolutions that a Kwil network can vote on,
// and define the resulting logic if the resolution receives the required number of votes.
type ResolutionConfig struct {
	// RefundThreshold is the required vote percentage threshold for all voters
	// on a resolution to be refunded the gas costs associated with voting.
	// This allows for resolutions that have not received enough votes to pass
	// to refund gas to the voters that have voted on the resolution.
	// For a 1/3rds threshold, >=1/3rds of the voters must vote for the resolution for refunds to occur.
	// If this threshold is not met, voters will not be refunded when the resolution expires.
	// The number must be a fraction between 0 and 1.
	// If this field is nil, it will default to only refunding voters when the resolution is confirmed.
	RefundThreshold *big.Rat
	// ConfirmationThreshold is the required vote percentage threshold for whether
	// a resolution is confirmed. In a 2/3rds threshold,
	// >=2/3rds of the voters must vote for the resolution for it to be confirmed.
	// Voters will also be refunded if this threshold is met,
	// regardless of the refund threshold.
	// The number must be a fraction between 0 and 1.
	// If this field is nil, it will default to 2/3.
	ConfirmationThreshold *big.Rat
	// ExpirationPeriod is the amount of blocks that the resolution will be valid for before it expires.
	// It is applied additively to the current block height when the resolution is proposed; if the
	// current block height is 10 and the expiration height is 5, the resolution will expire at block 15.
	// If this field is <1, it will default to 14400, which is approximately 1 day assuming 6 second blocks.
	ExpirationPeriod int64
	// ResolveFunc is a function that is called once a resolution has received a required number of votes,
	// as defined by the ConfirmationThreshold. It is given a readwrite database connection and the information
	// for the resolution that has been confirmed. All nodes will call this function as a part of block
	// execution. It is therefore expected that the function is deterministic, regardless of a node's
	// local configuration.
	ResolveFunc func(ctx context.Context, app *common.App, resolution *Resolution) error
}

// Resolution contains information for a resolution that can be voted on.
type Resolution struct {
	// ID is the unique identifier for the resolution.
	// It is a UUID that is deterministically generated from the body of the resolution.
	ID types.UUID
	// Body is the content of the resolution.
	// It can hold any arbitrary data that is relevant to the resolution.
	Body []byte
	// Type is the type of the resolution.
	// It is used to determine the logic for the resolution.
	Type string
	// ExpirationHeight is the block height at which the resolution is set to expire,
	// if it has not received the required number of votes.
	ExpirationHeight int64
	// ApprovedPower is the total power of the voters that have approved the resolution.
	ApprovedPower int64
	// Voters is a list of voters that have voted on the resolution.
	// This includes the proposer of the resolution.
	Voters []*types.Validator
	// Proposer is the voter that proposed the resolution body.
	// The power of the proposer can be found in the Voters list.
	Proposer []byte
	// DoubleProposerVote indicates whether or not the proposer voted twice on the resolution.
	// This tracks a special case in the Kwil voting process where a resolution can be voted
	// on before it has been officially proposed. If a validator votes on a resolution and\
	// later proposes the same resolution, this will be true. The proposer's power is not
	// counted twice in the resolution's ApprovedPower.
	// Most applications can ignore this field.
	DoubleProposerVote bool
}
```

_An example resolution that credits Kwil accounts with gas tokens can be found [here](<https://github.com/kwilteam/kwil-db/blob/main/extensions/resolutions/credit/credit.go>)._

**The `ResolveFunc` must be deterministic.** All nodes will run the `ResolveFunc` when a resolution is confirmed, and different results will create a consensus failure.

**Resolution bodies in `resolution.Body` must be unique.** The `ID` of a resolution is deterministically generated from the body of the resolution, and two resolutions with the same body will have the same ID.
The network will reject a resolution resolution with the same ID as an existing resolution.

## Resolution Voting

Currently, the only way to vote on a custom resolution is through the use of oracle extensions. In the future, we plan to allow resolutions to
be voted on directly using the CLI.

At the end of each block, the network will first check for all resolutions that have received enough votes to be confirmed. If a resolution has received
enough votes, the `ResolveFunc` will be called, and the resolution will be removed from the network. The network will then check for all resolutions that have
expired, and refund the gas costs to the voters if the refund threshold has been met.